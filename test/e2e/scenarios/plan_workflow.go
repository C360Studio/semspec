package scenarios

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/c360studio/semspec/test/e2e/client"
	"github.com/c360studio/semspec/test/e2e/config"
)

// PlanWorkflowScenario tests the ADR-003 workflow commands via HTTP gateway.
// Tests: /explore → /promote → /execute (dry-run) and /plan direct creation.
// This validates the backend is solid for UI development.
type PlanWorkflowScenario struct {
	name        string
	description string
	config      *config.Config
	http        *client.HTTPClient
	fs          *client.FilesystemClient
}

// NewPlanWorkflowScenario creates a new plan workflow scenario.
func NewPlanWorkflowScenario(cfg *config.Config) *PlanWorkflowScenario {
	return &PlanWorkflowScenario{
		name:        "plan-workflow",
		description: "Tests /explore, /promote, /plan, /execute commands via HTTP (ADR-003)",
		config:      cfg,
	}
}

// Name returns the scenario name.
func (s *PlanWorkflowScenario) Name() string {
	return s.name
}

// Description returns the scenario description.
func (s *PlanWorkflowScenario) Description() string {
	return s.description
}

// Setup prepares the scenario environment.
func (s *PlanWorkflowScenario) Setup(ctx context.Context) error {
	// Create filesystem client and setup workspace
	s.fs = client.NewFilesystemClient(s.config.WorkspacePath)
	if err := s.fs.SetupWorkspace(); err != nil {
		return fmt.Errorf("setup workspace: %w", err)
	}

	// Create HTTP client
	s.http = client.NewHTTPClient(s.config.HTTPBaseURL)

	// Wait for service to be healthy
	if err := s.http.WaitForHealthy(ctx); err != nil {
		return fmt.Errorf("service not healthy: %w", err)
	}

	return nil
}

// Execute runs the plan workflow scenario.
func (s *PlanWorkflowScenario) Execute(ctx context.Context) (*Result, error) {
	result := NewResult(s.name)
	defer result.Complete()

	stages := []struct {
		name string
		fn   func(context.Context, *Result) error
	}{
		{"explore-create", s.stageExploreCreate},
		{"explore-verify", s.stageExploreVerify},
		{"promote", s.stagePromote},
		{"promote-verify", s.stagePromoteVerify},
		// HTTP endpoint verification stages (run early, don't depend on execute)
		{"verify-404-responses", s.stageVerify404Responses},
		{"verify-context-endpoint", s.stageVerifyContextEndpoint},
		{"verify-reviews-endpoint", s.stageVerifyReviewsEndpoint},
		// These stages have known issues - tasks aren't generated by workflow
		{"execute-dry-run", s.stageExecuteDryRun},
		{"execute-verify", s.stageExecuteVerify},
		{"plan-direct", s.stagePlanDirect},
		{"plan-verify", s.stagePlanVerify},
	}

	for _, stage := range stages {
		stageStart := time.Now()
		// Use longer timeout for LLM-powered stages
		stageTimeout := s.config.StageTimeout
		if stage.name == "explore-create" || stage.name == "explore-verify" ||
			stage.name == "plan-direct" || stage.name == "plan-verify" {
			stageTimeout = 120 * time.Second // LLM can take a while
		}
		stageCtx, cancel := context.WithTimeout(ctx, stageTimeout)

		err := stage.fn(stageCtx, result)
		cancel()

		stageDuration := time.Since(stageStart)
		result.SetMetric(fmt.Sprintf("%s_duration_ms", stage.name), stageDuration.Milliseconds())

		if err != nil {
			result.AddStage(stage.name, false, stageDuration, err.Error())
			result.AddError(fmt.Sprintf("%s: %v", stage.name, err))
			result.Error = fmt.Sprintf("%s failed: %v", stage.name, err)
			return result, nil
		}

		result.AddStage(stage.name, true, stageDuration, "")
	}

	result.Success = true
	return result, nil
}

// Teardown cleans up after the scenario.
func (s *PlanWorkflowScenario) Teardown(ctx context.Context) error {
	// HTTP client doesn't need cleanup
	return nil
}

// stageExploreCreate sends the /explore command via HTTP.
func (s *PlanWorkflowScenario) stageExploreCreate(ctx context.Context, result *Result) error {
	explorationTopic := "authentication options"
	result.SetDetail("exploration_topic", explorationTopic)
	result.SetDetail("expected_slug", "authentication-options")

	resp, err := s.http.SendMessage(ctx, "/explore "+explorationTopic)
	if err != nil {
		return fmt.Errorf("send /explore command: %w", err)
	}

	result.SetDetail("explore_response_type", resp.Type)
	result.SetDetail("explore_response_content", resp.Content)
	result.SetDetail("explore_response", resp)

	// Verify response type is not error
	if resp.Type == "error" {
		return fmt.Errorf("explore returned error: %s", resp.Content)
	}

	// Verify response contains exploration confirmation
	content := strings.ToLower(resp.Content)
	hasExplorationInfo := strings.Contains(content, "exploration") ||
		strings.Contains(content, "created") ||
		strings.Contains(content, "authentication")

	if !hasExplorationInfo {
		return fmt.Errorf("explore response doesn't contain expected info: %s", resp.Content)
	}

	return nil
}

// stageExploreVerify verifies the exploration was created on the filesystem.
func (s *PlanWorkflowScenario) stageExploreVerify(ctx context.Context, result *Result) error {
	expectedSlug, _ := result.GetDetailString("expected_slug")

	// Wait for change directory to exist
	if err := s.fs.WaitForChange(ctx, expectedSlug); err != nil {
		return fmt.Errorf("exploration directory not created: %w", err)
	}

	// Verify plan.json exists
	if err := s.fs.WaitForChangeFile(ctx, expectedSlug, "plan.json"); err != nil {
		return fmt.Errorf("plan.json not created: %w", err)
	}

	// Load and verify plan.json
	planPath := s.fs.ChangePath(expectedSlug) + "/plan.json"
	var plan map[string]any
	if err := s.fs.ReadJSON(planPath, &plan); err != nil {
		return fmt.Errorf("read plan.json: %w", err)
	}

	// Verify plan is uncommitted
	committed, ok := plan["committed"].(bool)
	if !ok {
		return fmt.Errorf("plan.json missing 'committed' field")
	}
	if committed {
		return fmt.Errorf("exploration should be uncommitted, but committed=true")
	}

	result.SetDetail("explore_verified", true)
	result.SetDetail("plan_id", plan["id"])
	return nil
}

// stagePromote promotes the exploration to a committed plan.
func (s *PlanWorkflowScenario) stagePromote(ctx context.Context, result *Result) error {
	expectedSlug, _ := result.GetDetailString("expected_slug")

	// First, edit the plan to add execution steps
	planPath := s.fs.ChangePath(expectedSlug) + "/plan.json"
	var plan map[string]any
	if err := s.fs.ReadJSON(planPath, &plan); err != nil {
		return fmt.Errorf("read plan.json: %w", err)
	}

	// Add plan content for a realistic test
	plan["goal"] = "Explore OAuth, JWT, and session-based auth approaches"
	plan["context"] = "Need to evaluate authentication options for the API"
	plan["scope"] = map[string]any{
		"include": []string{"api/auth/*", "docs/auth.md"},
		"exclude": []string{"api/legacy/*"},
	}

	// Save updated plan
	data, err := json.MarshalIndent(plan, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal plan: %w", err)
	}
	if err := s.fs.WriteFile(planPath, string(data)); err != nil {
		return fmt.Errorf("write plan.json: %w", err)
	}

	// Now promote via HTTP
	resp, err := s.http.SendMessage(ctx, "/promote "+expectedSlug)
	if err != nil {
		return fmt.Errorf("send /promote command: %w", err)
	}

	result.SetDetail("promote_response_type", resp.Type)
	result.SetDetail("promote_response_content", resp.Content)
	result.SetDetail("promote_response", resp)

	// Verify response type is not error
	if resp.Type == "error" {
		return fmt.Errorf("promote returned error: %s", resp.Content)
	}

	// Verify response contains promotion confirmation
	content := strings.ToLower(resp.Content)
	hasPromotionInfo := strings.Contains(content, "committed") ||
		strings.Contains(content, "plan") ||
		strings.Contains(content, "promoted")

	if !hasPromotionInfo {
		return fmt.Errorf("promote response doesn't contain expected info: %s", resp.Content)
	}

	return nil
}

// stagePromoteVerify verifies the plan is now committed.
func (s *PlanWorkflowScenario) stagePromoteVerify(ctx context.Context, result *Result) error {
	expectedSlug, _ := result.GetDetailString("expected_slug")

	// Load plan.json
	planPath := s.fs.ChangePath(expectedSlug) + "/plan.json"
	var plan map[string]any
	if err := s.fs.ReadJSON(planPath, &plan); err != nil {
		return fmt.Errorf("read plan.json: %w", err)
	}

	// Verify plan is now committed
	committed, ok := plan["committed"].(bool)
	if !ok {
		return fmt.Errorf("plan.json missing 'committed' field")
	}
	if !committed {
		return fmt.Errorf("plan should be committed after /promote, but committed=false")
	}

	// Verify committed_at is set
	if plan["committed_at"] == nil {
		return fmt.Errorf("plan.json missing 'committed_at' field")
	}

	result.SetDetail("promote_verified", true)
	return nil
}

// stageExecuteDryRun tests /execute without --run flag (dry run).
func (s *PlanWorkflowScenario) stageExecuteDryRun(ctx context.Context, result *Result) error {
	expectedSlug, _ := result.GetDetailString("expected_slug")

	resp, err := s.http.SendMessage(ctx, "/execute "+expectedSlug)
	if err != nil {
		return fmt.Errorf("send /execute command: %w", err)
	}

	result.SetDetail("execute_response_type", resp.Type)
	result.SetDetail("execute_response_content", resp.Content)
	result.SetDetail("execute_response", resp)

	// Verify response type is not error
	if resp.Type == "error" {
		return fmt.Errorf("execute returned error: %s", resp.Content)
	}

	// Verify response contains task information
	content := strings.ToLower(resp.Content)
	hasTaskInfo := strings.Contains(content, "task") ||
		strings.Contains(content, "generated") ||
		strings.Contains(content, "execution")

	if !hasTaskInfo {
		return fmt.Errorf("execute response doesn't contain task info: %s", resp.Content)
	}

	return nil
}

// stageExecuteVerify verifies tasks.json was created.
func (s *PlanWorkflowScenario) stageExecuteVerify(ctx context.Context, result *Result) error {
	expectedSlug, _ := result.GetDetailString("expected_slug")

	// Verify tasks.json was created
	if err := s.fs.WaitForChangeFile(ctx, expectedSlug, "tasks.json"); err != nil {
		return fmt.Errorf("tasks.json not created: %w", err)
	}

	// Load and verify tasks
	tasksPath := s.fs.ChangePath(expectedSlug) + "/tasks.json"
	var tasks []map[string]any
	if err := s.fs.ReadJSON(tasksPath, &tasks); err != nil {
		return fmt.Errorf("read tasks.json: %w", err)
	}

	// We added 4 execution steps, should have 4 tasks
	if len(tasks) != 4 {
		return fmt.Errorf("expected 4 tasks, got %d", len(tasks))
	}

	result.SetDetail("execute_verified", true)
	result.SetDetail("task_count", len(tasks))
	return nil
}

// stagePlanDirect tests /plan which creates a committed plan directly.
func (s *PlanWorkflowScenario) stagePlanDirect(ctx context.Context, result *Result) error {
	planTitle := "implement caching layer"
	result.SetDetail("plan_title", planTitle)
	result.SetDetail("plan_slug", "implement-caching-layer")

	resp, err := s.http.SendMessage(ctx, "/plan "+planTitle)
	if err != nil {
		return fmt.Errorf("send /plan command: %w", err)
	}

	result.SetDetail("plan_response_type", resp.Type)
	result.SetDetail("plan_response_content", resp.Content)
	result.SetDetail("plan_response", resp)

	// Verify response type is not error
	if resp.Type == "error" {
		return fmt.Errorf("plan returned error: %s", resp.Content)
	}

	// Verify response contains plan confirmation
	content := strings.ToLower(resp.Content)
	hasPlanInfo := strings.Contains(content, "plan") ||
		strings.Contains(content, "created") ||
		strings.Contains(content, "committed")

	if !hasPlanInfo {
		return fmt.Errorf("plan response doesn't contain expected info: %s", resp.Content)
	}

	return nil
}

// stagePlanVerify verifies the directly created plan is committed and has LLM-generated content.
func (s *PlanWorkflowScenario) stagePlanVerify(ctx context.Context, result *Result) error {
	planSlug, _ := result.GetDetailString("plan_slug")

	// Wait for change directory to exist
	if err := s.fs.WaitForChange(ctx, planSlug); err != nil {
		return fmt.Errorf("plan directory not created: %w", err)
	}

	// Verify plan.json exists
	if err := s.fs.WaitForChangeFile(ctx, planSlug, "plan.json"); err != nil {
		return fmt.Errorf("plan.json not created: %w", err)
	}

	planPath := s.fs.ChangePath(planSlug) + "/plan.json"

	// Poll for Goal to be populated by LLM (planner processor)
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return fmt.Errorf("timeout waiting for plan Goal to be populated by LLM")
		case <-ticker.C:
			var plan map[string]any
			if err := s.fs.ReadJSON(planPath, &plan); err != nil {
				continue
			}

			// Verify plan is committed
			committed, ok := plan["committed"].(bool)
			if !ok || !committed {
				continue
			}

			// Check if Goal is populated by LLM
			goal, hasGoal := plan["goal"].(string)
			if hasGoal && goal != "" {
				result.SetDetail("plan_direct_verified", true)
				result.SetDetail("goal", goal)
				if planContext, ok := plan["context"].(string); ok {
					result.SetDetail("context", planContext)
				}
				return nil
			}
		}
	}
}

// stageVerify404Responses tests that the HTTP endpoints return 404 for nonexistent data.
func (s *PlanWorkflowScenario) stageVerify404Responses(ctx context.Context, result *Result) error {
	// Test nonexistent context response - should return 404
	_, status, _ := s.http.GetContextBuilderResponse(ctx, "nonexistent-request-id-12345")
	if status != 404 {
		return fmt.Errorf("context endpoint: expected 404 for missing ID, got %d", status)
	}
	result.SetDetail("context_404_verified", true)

	// Test nonexistent plan reviews - should return 404
	_, status, _ = s.http.GetPlanReviews(ctx, "nonexistent-plan-slug-xyz")
	if status != 404 {
		return fmt.Errorf("reviews endpoint: expected 404 for missing slug, got %d", status)
	}
	result.SetDetail("reviews_404_verified", true)

	result.SetDetail("404_handling_verified", true)
	return nil
}

// stageVerifyContextEndpoint tests the GET /context-builder/responses/{request_id} endpoint.
func (s *PlanWorkflowScenario) stageVerifyContextEndpoint(ctx context.Context, result *Result) error {
	// Look for context request IDs in CONTEXT_RESPONSES bucket
	kvResp, err := s.http.GetKVEntries(ctx, "CONTEXT_RESPONSES")
	if err != nil {
		// Bucket may not exist if no context was requested during workflow
		result.SetDetail("context_responses_available", false)
		result.SetDetail("context_responses_note", "bucket not found or empty - context building may not have been triggered")
		return nil // Not a failure - context building is optional in this workflow
	}

	if len(kvResp.Entries) == 0 {
		result.SetDetail("context_responses_available", false)
		result.SetDetail("context_responses_note", "no context responses stored")
		return nil
	}

	// Test retrieval of first available response via HTTP endpoint
	requestID := kvResp.Entries[0].Key
	resp, status, err := s.http.GetContextBuilderResponse(ctx, requestID)
	if err != nil {
		return fmt.Errorf("get context response via HTTP: %w", err)
	}

	if status != 200 {
		return fmt.Errorf("expected HTTP 200, got %d", status)
	}

	// Verify response structure
	if resp.RequestID != requestID {
		return fmt.Errorf("request_id mismatch: got %s, want %s", resp.RequestID, requestID)
	}

	result.SetDetail("context_responses_available", true)
	result.SetDetail("context_response_verified", true)
	result.SetDetail("context_request_id", requestID)
	result.SetDetail("context_task_type", resp.TaskType)
	result.SetDetail("context_tokens_used", resp.TokensUsed)
	return nil
}

// stageVerifyReviewsEndpoint tests the GET /workflow-api/plans/{slug}/reviews endpoint.
func (s *PlanWorkflowScenario) stageVerifyReviewsEndpoint(ctx context.Context, result *Result) error {
	// Use the slug from earlier explore stage
	slug := "authentication-options"

	resp, status, err := s.http.GetPlanReviews(ctx, slug)
	if err != nil && status != 404 {
		return fmt.Errorf("get plan reviews via HTTP: %w", err)
	}

	if status == 404 {
		// No review workflow completed yet - this is valid for this test scenario
		result.SetDetail("reviews_available", false)
		result.SetDetail("reviews_status", 404)
		result.SetDetail("reviews_note", "no review workflow completed for this plan - expected in basic workflow test")
		return nil
	}

	// Verify response structure if data exists
	if resp.Verdict == "" {
		return fmt.Errorf("missing verdict in response")
	}

	result.SetDetail("reviews_available", true)
	result.SetDetail("reviews_verdict", resp.Verdict)
	result.SetDetail("reviews_passed", resp.Passed)
	result.SetDetail("reviews_summary", resp.Summary)
	return nil
}
