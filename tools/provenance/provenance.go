// Package provenance provides PROV-O provenance helpers for tool executors.
package provenance

import (
	"time"

	"github.com/c360studio/semstreams/message"
)

// Provenance predicates aligned with PROV-O vocabulary.
// Uses three-part dotted notation: domain.category.property
// as specified in docs/spec/semspec-vocabulary-spec.md
const (
	// Generation - entity was generated by an activity
	ProvGeneratedBy = "prov.generation.activity"
	// Attribution - entity attributed to an agent
	ProvAttributedTo = "prov.attribution.agent"
	// Derivation - entity derived from another entity
	ProvDerivedFrom = "prov.derivation.source"
	// Usage - activity used an entity
	ProvUsed = "prov.usage.entity"
	// Association - activity associated with an agent
	ProvAssociatedWith = "prov.association.agent"
	// Delegation - agent acted on behalf of another agent
	ProvActedOnBehalfOf = "prov.delegation.principal"

	// Timestamps
	ProvStartedAt   = "prov.time.started"
	ProvEndedAt     = "prov.time.ended"
	ProvGeneratedAt = "prov.time.generated"

	// Agentic action predicates
	AgenticActionType    = "agentic.action.type"
	AgenticActionAgent   = "agentic.action.agent"
	AgenticActionInput   = "agentic.action.input"
	AgenticActionOutput  = "agentic.action.output"
	AgenticActionSuccess = "agentic.action.success"
	AgenticActionError   = "agentic.action.error"
)

// ActionType represents the type of agentic action
type ActionType string

const (
	ActionTypeToolCall  ActionType = "tool_call"
	ActionTypeModelCall ActionType = "model_call"
	ActionTypeDecision  ActionType = "decision"
)

// ProvenanceContext holds context for provenance emission
type ProvenanceContext struct {
	// LoopID is the ID of the agent loop executing the action
	LoopID string
	// AgentID is the ID of the agent (user or model)
	AgentID string
	// CallID is the unique identifier for the tool call
	CallID string
	// ToolName is the name of the tool being executed
	ToolName string
}

// NewProvenanceContext creates a new provenance context
func NewProvenanceContext(loopID, agentID, callID, toolName string) *ProvenanceContext {
	return &ProvenanceContext{
		LoopID:   loopID,
		AgentID:  agentID,
		CallID:   callID,
		ToolName: toolName,
	}
}

// ActionTriples generates triples for a tool action
func (ctx *ProvenanceContext) ActionTriples(success bool, errorMsg string) []message.Triple {
	now := time.Now().Format(time.RFC3339)
	triples := []message.Triple{
		{Subject: ctx.CallID, Predicate: AgenticActionType, Object: string(ActionTypeToolCall)},
		{Subject: ctx.CallID, Predicate: ProvStartedAt, Object: now},
		{Subject: ctx.CallID, Predicate: AgenticActionSuccess, Object: success},
	}

	if ctx.AgentID != "" {
		triples = append(triples,
			message.Triple{Subject: ctx.CallID, Predicate: AgenticActionAgent, Object: ctx.AgentID})
	}

	if ctx.LoopID != "" {
		triples = append(triples,
			message.Triple{Subject: ctx.CallID, Predicate: ProvAssociatedWith, Object: ctx.LoopID})
	}

	if !success && errorMsg != "" {
		triples = append(triples,
			message.Triple{Subject: ctx.CallID, Predicate: AgenticActionError, Object: errorMsg})
	}

	return triples
}

// GenerationTriples generates triples for an entity created by a tool action
func (ctx *ProvenanceContext) GenerationTriples(entityID string) []message.Triple {
	now := time.Now().Format(time.RFC3339)
	triples := []message.Triple{
		// Entity was generated by this tool call
		{Subject: entityID, Predicate: ProvGeneratedBy, Object: ctx.CallID},
		// When it was generated
		{Subject: entityID, Predicate: ProvGeneratedAt, Object: now},
	}

	// Attribution to loop/agent
	if ctx.LoopID != "" {
		triples = append(triples,
			message.Triple{Subject: entityID, Predicate: ProvAttributedTo, Object: ctx.LoopID})
	}
	if ctx.AgentID != "" {
		triples = append(triples,
			message.Triple{Subject: entityID, Predicate: ProvAttributedTo, Object: ctx.AgentID})
	}

	// Link tool call output
	triples = append(triples,
		message.Triple{Subject: ctx.CallID, Predicate: AgenticActionOutput, Object: entityID})

	return triples
}

// UsageTriples generates triples for an entity used by a tool action
func (ctx *ProvenanceContext) UsageTriples(entityID string) []message.Triple {
	return []message.Triple{
		// Tool call used this entity
		{Subject: ctx.CallID, Predicate: ProvUsed, Object: entityID},
		// Link as action input
		{Subject: ctx.CallID, Predicate: AgenticActionInput, Object: entityID},
	}
}

// ModificationTriples generates triples for an entity modified by a tool action
// (combines usage and generation semantics)
func (ctx *ProvenanceContext) ModificationTriples(entityID, previousHash string) []message.Triple {
	now := time.Now().Format(time.RFC3339)
	triples := []message.Triple{
		// Modified by this tool call
		{Subject: entityID, Predicate: ProvGeneratedBy, Object: ctx.CallID},
		{Subject: entityID, Predicate: ProvGeneratedAt, Object: now},
		// Previous version derivation
		{Subject: entityID, Predicate: ProvDerivedFrom, Object: entityID + "@" + previousHash},
	}

	if ctx.LoopID != "" {
		triples = append(triples,
			message.Triple{Subject: entityID, Predicate: ProvAttributedTo, Object: ctx.LoopID})
	}

	return triples
}

// CommitTriples generates triples for a git commit action
func (ctx *ProvenanceContext) CommitTriples(commitHash, commitMsg string, files []string) []message.Triple {
	now := time.Now().Format(time.RFC3339)
	commitID := "git.commit." + commitHash

	triples := []message.Triple{
		{Subject: commitID, Predicate: ProvGeneratedBy, Object: ctx.CallID},
		{Subject: commitID, Predicate: ProvGeneratedAt, Object: now},
		{Subject: commitID, Predicate: "dc.terms.title", Object: commitMsg},
	}

	if ctx.AgentID != "" {
		triples = append(triples,
			message.Triple{Subject: commitID, Predicate: ProvAttributedTo, Object: ctx.AgentID})
	}

	// Each file in the commit
	for _, f := range files {
		fileID := "code.file." + f
		triples = append(triples,
			message.Triple{Subject: commitID, Predicate: "code.structure.contains", Object: fileID})
	}

	return triples
}
