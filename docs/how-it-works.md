# How Semspec Works

This document explains what happens when you use semspec, from infrastructure to command execution.

## What is Semspec?

Semspec is a spec-driven development agent with a **persistent knowledge graph**. It helps you:

- Create structured proposals, designs, and specifications
- Track code entities (functions, types, packages) across your codebase
- Query context that persists across sessions

**The key insight**: Traditional AI coding assistants lose context between sessions. Semspec stores everything in a knowledge graph, so your AI assistant remembers your codebase, your proposals, and your decisions.

## The Semstreams Relationship

Semspec is an **extension** of semstreams, not a standalone tool.

```
┌─────────────────────────────────────────────────────────┐
│  semstreams (infrastructure library)                     │
│  ├── NATS messaging                                      │
│  ├── agentic-loop (LLM reasoning)                       │
│  ├── agentic-model (LLM API calls)                      │
│  ├── graph-* (knowledge graph storage)                  │
│  └── component lifecycle                                 │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ imports as library
                          │
┌─────────────────────────────────────────────────────────┐
│  semspec (this project)                                  │
│  ├── Workflow commands (/propose, /design, etc.)        │
│  ├── AST indexer (parses code, emits to graph)          │
│  ├── Workflow orchestrator (chains steps)               │
│  └── File/git tools                                      │
└─────────────────────────────────────────────────────────┘
```

**What this means for you**:

1. Semspec imports semstreams as a Go library
2. Docker-compose runs semstreams components (the ones that call LLMs)
3. Semspec binary runs semspec-specific components (AST indexer, workflow commands)

## What You Need Running

When you use semspec, three things are running:

| Component | Where | What It Does |
|-----------|-------|--------------|
| **NATS JetStream** | Docker | Message bus connecting everything |
| **Semstreams services** | Docker | LLM calls, graph storage, agent loops |
| **Semspec binary** | Local | Your commands, code parsing, tool execution |

This is why you need docker-compose before running semspec:

```bash
# In semstreams repo - starts NATS + semstreams services
docker-compose -f docker/compose/e2e.yml up -d

# Then run semspec
./semspec cli --repo .
```

## What Happens When You Run a Command

Let's trace `/propose Add user authentication`:

```
┌─ WEB UI OR CLI ─────────────────────────────────────────┐
│  "Add user authentication"                               │
│  (or /propose Add user authentication in CLI)           │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ SEMSPEC BINARY ────────────────────────────────────────┐
│  1. Parse command                                        │
│  2. Create WorkflowTaskPayload                          │
│  3. Publish to NATS: agent.task.workflow                │
│  4. Return immediately (async)                          │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ NATS JETSTREAM ────────────────────────────────────────┐
│  Durable message queue                                   │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ SEMSTREAMS (in Docker) ────────────────────────────────┐
│  agentic-loop (consumes message)                        │
│       │                                                  │
│       ▼                                                  │
│  agentic-model (calls LLM API)                          │
│       │                                                  │
│       ▼                                                  │
│  Writes proposal.md to your filesystem                  │
│       │                                                  │
│       ▼                                                  │
│  Stores completion in KV: AGENT_LOOPS                   │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ YOUR FILESYSTEM ───────────────────────────────────────┐
│  .semspec/changes/add-user-authentication/              │
│    ├── proposal.md     ← Generated by LLM              │
│    └── metadata.json                                    │
└──────────────────────────────────────────────────────────┘
```

**Key points**:
- Your command returns immediately
- LLM processing happens asynchronously in Docker
- Results appear in `.semspec/changes/`

## LLM Configuration

Semspec requires an LLM to generate proposals, designs, and specifications.

### Option 1: Ollama (Default)

Semspec is designed to run with local LLMs. Start Ollama:
```bash
ollama serve
ollama pull qwen2.5-coder:14b
```

The default configuration uses `qwen` as the default model.

### Option 2: Claude API (Optional)

For cloud-connected environments, you can optionally use Claude:
```bash
export ANTHROPIC_API_KEY=sk-ant-...
```

This provides access to more capable models for complex reasoning tasks.

**Note**: "LLM optional" in some docs means "Claude API optional if Ollama is running" - not that LLM is optional. An LLM is always required.

### Model Selection

By default, semspec uses capability-based selection:

| Step | Capability | Local Model | Cloud Model (if available) |
|------|------------|-------------|----------------------------|
| /propose | writing | qwen | claude-sonnet |
| /design | planning | qwen | claude-opus |
| /spec | writing | qwen | claude-sonnet |
| /tasks | planning | qwen | claude-opus |

Override with flags:
```bash
/propose Add auth --capability fast    # Use faster model
/propose Add auth --model qwen         # Use specific model
```

## Autonomous Mode

The `--auto` flag chains workflow steps automatically:

```bash
/propose Add user authentication --auto
```

What happens:
1. **proposal.md** generated
2. Validator checks document structure
3. If valid, **design.md** generated
4. Validator checks design
5. If valid, **spec.md** generated
6. Validator checks spec
7. If valid, **tasks.md** generated
8. Notification sent

If validation fails, the system retries up to 3 times with feedback to the LLM about what's missing.

**Why this takes time**: Each step requires an LLM call. Four steps means four calls, plus potential retries. This is expected behavior.

## The Knowledge Graph

Semspec stores two types of entities in its knowledge graph:

### Code Entities (from AST indexer)

The AST indexer parses your code and extracts:
- Functions and methods
- Types and interfaces
- Packages and imports

These are published to `graph.ingest.entity` and stored for querying.

### Workflow Entities (from proposals)

Each proposal, design, spec, and task becomes a graph entity with predicates describing its status, content, and relationships.

### Querying Context

Use `/context` to query the graph:
```bash
/context What functions handle authentication?
```

This queries stored code entities to provide relevant context.

## File Structure

After running workflows, your project contains:

```
your-project/
├── .semspec/
│   ├── constitution.md          # Project rules (optional)
│   └── changes/
│       └── add-user-authentication/
│           ├── metadata.json    # Status, timestamps
│           ├── proposal.md      # Problem statement
│           ├── design.md        # Technical design
│           ├── spec.md          # GIVEN/WHEN/THEN
│           └── tasks.md         # Implementation checklist
└── ... your code ...
```

These files are git-friendly. Commit them to preserve context.

## Interfaces

Semspec offers three ways to interact:

### Web UI (Primary)

The web interface is the main way humans interact with semspec:

```bash
./semspec --repo .
# Open http://localhost:8080 in your browser
```

The UI provides:
- **Chat**: Primary interaction point - type messages, see responses
- **Entity Browser**: Search and explore the knowledge graph
- **Tasks**: Monitor active loops, pause/resume workflows
- **Real-time Activity**: SSE-powered live updates

### CLI (Quick Use)

For quick commands or automation:

```bash
./semspec cli --repo .
```

Type commands directly in the terminal. Useful for:
- Quick one-off proposals
- Scripting and automation
- Advanced users who prefer terminal

### HTTP API (Programmatic)

For integration with other tools:

| Endpoint | Purpose |
|----------|---------|
| `POST /agentic-dispatch/message` | Send messages |
| `GET /agentic-dispatch/loops` | List active loops |
| `GET /agentic-dispatch/activity` | SSE event stream |

## Debugging

### Check Message Flow

```bash
# View recent messages
curl http://localhost:8080/message-logger/entries?limit=50

# Check KV state
curl http://localhost:8080/message-logger/kv/AGENT_LOOPS
```

### Check Container Logs

```bash
docker-compose -f docker/compose/e2e.yml logs -f semspec
```

### Check NATS Health

```bash
curl http://localhost:8222/healthz
```

## Next Steps

- [Getting Started](getting-started.md) - Quick setup and first proposal
- [Architecture](architecture.md) - Technical deep-dive
- [Workflow System](workflow-system.md) - Validation and orchestration details
