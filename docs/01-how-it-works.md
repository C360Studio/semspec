# How Semspec Works

This document explains what happens when you use semspec, from infrastructure to command execution.

## What is Semspec?

Semspec is a spec-driven development agent with a **persistent knowledge graph**. It helps you:

- Create structured proposals, designs, and specifications
- Track code entities (functions, types, packages) across your codebase
- Query context that persists across sessions

**The key insight**: Traditional AI coding assistants lose context between sessions. Semspec stores everything in a knowledge graph, so your AI assistant remembers your codebase, your proposals, and your decisions.

## The Semstreams Relationship

Semspec is an **extension** of semstreams, not a standalone tool.

```
┌─────────────────────────────────────────────────────────┐
│  semstreams (infrastructure library)                     │
│  ├── NATS messaging                                      │
│  ├── agentic-loop (LLM reasoning)                       │
│  ├── agentic-model (LLM API calls)                      │
│  ├── graph-* (knowledge graph storage)                  │
│  └── component lifecycle                                 │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ imports as library
                          │
┌─────────────────────────────────────────────────────────┐
│  semspec (this project)                                  │
│  ├── Workflow commands (/plan, /approve, /execute)      │
│  ├── AST indexer (parses code, emits to graph)          │
│  ├── Workflow orchestrator (chains steps)               │
│  └── File/git tools                                      │
└─────────────────────────────────────────────────────────┘
```

**What this means for you**:

1. Semspec imports semstreams as a Go library
2. Docker-compose runs semstreams components (the ones that call LLMs)
3. Semspec binary runs semspec-specific components (AST indexer, workflow commands)

## What You Need Running

With docker-compose (recommended):

| Component | Container | Purpose |
|-----------|-----------|---------|
| **NATS JetStream** | `nats` | Message bus for all communication |
| **Semspec** | `semspec` | Your commands, code parsing, tool execution |
| **Ollama** | External (host) | LLM inference |

```bash
# Start NATS and semspec together
docker compose up -d

# That's it - open http://localhost:8080
```

For development (building from source):

```bash
# Start just NATS from docker-compose
docker compose up -d nats

# Run semspec locally
./semspec --repo .
```

## What Happens When You Run a Command

Let's trace `/plan Add user authentication`:

```
┌─ WEB UI ────────────────────────────────────────────────┐
│  /plan Add user authentication                           │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ SEMSPEC BINARY ────────────────────────────────────────┐
│  1. Parse command                                        │
│  2. Create WorkflowTaskPayload                          │
│  3. Publish to NATS: agent.task.workflow                │
│  4. Return immediately (async)                          │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ NATS JETSTREAM ────────────────────────────────────────┐
│  Durable message queue                                   │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ SEMSTREAMS (in Docker) ────────────────────────────────┐
│  agentic-loop (consumes message)                        │
│       │                                                  │
│       ▼                                                  │
│  agentic-model (calls LLM API)                          │
│       │                                                  │
│       ▼                                                  │
│  Writes plan.md to your filesystem                      │
│       │                                                  │
│       ▼                                                  │
│  Stores completion in KV: AGENT_LOOPS                   │
└──────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─ YOUR FILESYSTEM ───────────────────────────────────────┐
│  .semspec/plans/add-user-authentication/                │
│    ├── plan.md         ← Generated by LLM              │
│    └── metadata.json                                    │
└──────────────────────────────────────────────────────────┘
```

**Key points**:
- Your command returns immediately
- LLM processing happens asynchronously in Docker
- Results appear in `.semspec/plans/`

## LLM Configuration

Semspec requires an LLM to generate proposals, designs, and specifications.

### Option 1: Ollama (Default)

Semspec is designed to run with local LLMs. Start Ollama:
```bash
ollama serve
ollama pull qwen2.5-coder:14b
```

The default configuration uses `qwen` as the default model.

### Option 2: Claude API (Optional)

For cloud-connected environments, you can optionally use Claude:
```bash
export ANTHROPIC_API_KEY=sk-ant-...
```

This provides access to more capable models for complex reasoning tasks.

**Note**: "LLM optional" in some docs means "Claude API optional if Ollama is running" - not that LLM is optional. An LLM is always required.

### Model Selection

By default, semspec uses capability-based selection:

| Step | Capability | Local Model | Cloud Model (if available) |
|------|------------|-------------|----------------------------|
| /plan | planning | qwen | claude-opus |
| /tasks | planning | qwen | claude-opus |
| /execute | coding | qwen | claude-sonnet |

Override with flags:
```bash
/plan Add auth --capability fast    # Use faster model
/plan Add auth --model qwen         # Use specific model
```

## Autonomous Mode

The `--auto` flag chains workflow steps automatically:

```bash
/plan Add user authentication --auto
```

What happens:
1. **plan.md** generated with Goal, Context, Scope
2. Validator checks document structure
3. If valid, **tasks.md** generated
4. Validator checks tasks
5. If valid, tasks are executed
6. Notification sent

If validation fails, the system retries up to 3 times with feedback to the LLM about what's missing.

**Why this takes time**: Each step requires an LLM call. Multiple steps means multiple calls, plus potential retries. This is expected behavior.

## The Knowledge Graph

Semspec stores two types of entities in its knowledge graph:

### Code Entities (from AST indexer)

The AST indexer parses your code and extracts:
- Functions and methods
- Types and interfaces
- Packages and imports

These are published to `graph.ingest.entity` and stored for querying.

### Workflow Entities (from plans)

Each plan and task becomes a graph entity with predicates describing its status, content, and relationships.

### Querying Context

Use `/context` to query the graph:
```bash
/context What functions handle authentication?
```

This queries stored code entities to provide relevant context.

## File Structure

After running workflows, your project contains:

```
your-project/
├── .semspec/
│   ├── constitution.md          # Project rules (optional)
│   └── plans/
│       └── add-user-authentication/
│           ├── metadata.json    # Status, timestamps
│           ├── plan.md          # Goal, context, scope
│           └── tasks.md         # Implementation checklist
└── ... your code ...
```

These files are git-friendly. Commit them to preserve context.

## Interfaces

Semspec provides two ways to interact:

### Web UI (Primary)

The web interface is the main way humans interact with semspec:

```bash
./semspec --repo .
# Open http://localhost:8080 in your browser
```

The UI provides:
- **Chat**: Primary interaction point - type messages, see responses
- **Entity Browser**: Search and explore the knowledge graph
- **Tasks**: Monitor active loops, pause/resume workflows
- **Real-time Activity**: SSE-powered live updates

### HTTP API (Programmatic)

For integration with other tools:

| Endpoint | Purpose |
|----------|---------|
| `POST /agentic-dispatch/message` | Send messages |
| `GET /agentic-dispatch/loops` | List active loops |
| `GET /agentic-dispatch/activity` | SSE event stream |

## Debugging

### Using /debug Command

The `/debug` command provides trace correlation and debugging tools:

```bash
# Query all messages in a trace
/debug trace 0af7651916cd43dd8448eb211c80319c

# Export debug snapshot to file for sharing with support
/debug snapshot 0af7651916cd43dd8448eb211c80319c --verbose
# Creates: .semspec/debug/{trace_id}.md

# Check workflow state for a change
/debug workflow add-user-auth

# Check agent loop state from KV
/debug loop loop_456
```

To find trace IDs:
```bash
# From recent messages
curl http://localhost:8080/message-logger/entries?limit=10 | jq '.[].trace_id'
```

Run `/debug help` for full command reference.

### Check Message Flow

```bash
# View recent messages
curl http://localhost:8080/message-logger/entries?limit=50

# Check KV state
curl http://localhost:8080/message-logger/kv/AGENT_LOOPS

# Query messages by trace ID (requires trace indexing)
curl http://localhost:8080/message-logger/trace/{traceID}
```

### Check Container Logs

```bash
docker compose logs -f semspec
```

### Check NATS Health

```bash
curl http://localhost:8222/healthz
```

## Next Steps

- [Getting Started](02-getting-started.md) - Quick setup and first plan
- [Architecture](03-architecture.md) - Technical deep-dive
- [Workflow System](05-workflow-system.md) - Validation and orchestration details
