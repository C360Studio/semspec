schema: spec-driven

# Project context
context: |
  Semspec is a semantic knowledge graph-based dev agent with persistent memory
  and multi-agent capabilities, built on SemStreams primitives.

  Tech stack:
  - Go 1.25+
  - SemStreams (NATS-based messaging, KV storage)
  - Ollama for local LLM inference (qwen2.5-coder, deepseek-coder)
  - BFO/CCO/PROV-O aligned vocabulary for semantic interoperability

  Architecture:
  - Agent-first, not infrastructure-first
  - Local-first (no cloud API dependencies by default)
  - Interaction layer: input adapters (CLI, future: Slack/Discord) → router → agentic components
  - Agentic components: agentic-loop, agentic-model, agentic-tools
  - Specialized roles: planner, architect, editor, reviewer (architect/editor split pattern)
  - Training flywheel: capture trajectories → human feedback → export → fine-tune SLMs

  Key differentiators:
  - Persistent semantic knowledge graph (not session-based context)
  - Fluid workflows with human checkpoints (not rigid phase gates)
  - Brownfield-first (designed for existing codebases, not just greenfield)

  Conventions:
  - Conventional commits: <type>(scope): subject
  - Go idioms and best practices
  - Entity IDs: six-part dotted notation ({org}.{platform}.{system}.{domain}.{type}.{instance})
  - Predicates: three-part dotted notation (domain.category.property)

  SemStreams dependency (../semstreams):
  The following components ALREADY EXIST and should be reused, not rebuilt:
  - processor/input/cli: CLI input adapter with Ctrl+C handling, REPL mode
  - processor/router: Message router with command parsing, loop tracking, permissions
  - processor/agentic-loop: Orchestrates agent state machine, handles signals
  - processor/agentic-model: Calls LLMs via OpenAI-compatible API (works with Ollama)
  - processor/agentic-tools: Executes tool calls with timeout, allowlist filtering
  - agentic/types.go: Core types (TaskMessage, LoopState, ToolCall, ToolResult)
  - agentic/user_types.go: User interaction types (UserMessage, UserSignal, UserResponse)

  Semspec builds ON TOP of SemStreams - it wires these components together and adds:
  - cmd/semspec CLI binary
  - Tool executors (file ops, git ops)
  - Entity storage (proposals, tasks, results)
  - Model/project configuration

# Per-artifact rules
rules:
  proposal:
    - Keep proposals concise - focus on WHY and WHAT, not HOW
    - Always include a "Non-goals" section to clarify scope
    - List affected entities/files in Impact section

  specs:
    - Use WHEN/THEN/AND format for testable requirements
    - Reference design principles from architecture decisions when relevant
    - Include constitution compliance check considerations

  design:
    - Always include "Alternatives Considered" section
    - Document key decisions with rationale
    - Reference relevant ADRs or prior decisions

  tasks:
    - Break tasks into single-PR-sized chunks
    - Each task should be independently testable
    - Order tasks by dependency (predecessors before successors)
